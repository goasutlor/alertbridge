"""Alert Receiver - HTTP/HTTPS webhook receiver with API Key auth, pattern mapping, alarm list."""
import json
import logging
import os
import time
import uuid
from collections import deque
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Optional

from fastapi import Depends, FastAPI, HTTPException, Request, Response
from fastapi.responses import FileResponse, JSONResponse

from app.api_key_auth import require_api_key
from app.api_keys import generate_api_key, list_api_keys, revoke_api_key
from app.config import (
    ApiPattern,
    FieldMapping,
    PatternRules,
    get_pattern_by_source,
    get_pattern_for_source,
    get_rules,
    load_rules,
    save_rules,
)
from app.mapper import map_payload_to_fields
from app.pattern_gen import auto_gen_mappings, gen_expected_json

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("alarm_receiver")

app = FastAPI(title="Alert Reciever", version="1.0.07022026")

BASE_DIR = Path(__file__).resolve().parent
TEMPLATE_FILE = BASE_DIR / "templates" / "index.html"
MAX_BODY_BYTES = 1 * 1024 * 1024  # 1 MiB

# In-memory alarm list (mapped fields) - newest last
ALARMS: deque = deque(maxlen=1000)


@app.get("/")
async def index() -> Response:
    """Serve web dashboard."""
    return FileResponse(TEMPLATE_FILE)


@app.get("/favicon.ico")
async def favicon() -> Response:
    """Avoid 404 when browser requests favicon."""
    return Response(status_code=204)


@app.get("/info")
async def info() -> Response:
    """Identify this app - use to verify Alert Receiver is running."""
    return JSONResponse({"app": "Alert Reciever", "version": "1.0.07022026"})


@app.on_event("startup")
async def startup() -> None:
    load_rules()


@app.middleware("http")
async def security_headers(request: Request, call_next) -> Response:
    response = await call_next(request)
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    return response


def _read_body(request: Request, max_bytes: int) -> bytes:
    import asyncio
    body = b""
    async def stream():
        nonlocal body
        async for chunk in request.stream():
            body += chunk
            if len(body) > max_bytes:
                raise HTTPException(status_code=413, detail="Request body too large")
    # Need to read body; FastAPI reads it - we use request.body() via manual read
    # Better: read in route with limit
    return b""  # Placeholder - we'll read in route


# ---------- Webhook: receive alarm (requires API Key, reject if not valid) ----------

@app.post("/webhook/{source}")
async def webhook_receive(
    source: str,
    request: Request,
    _api_key: str = Depends(require_api_key),
) -> Response:
    """
    Receive alarm webhook. Requires valid API key (X-API-Key or Authorization: Bearer).
    Rejects requests without API key or with key not generated by this system.
    """
    request_id = str(uuid.uuid4())[:8]
    body = b""
    async for chunk in request.stream():
        body += chunk
        if len(body) > MAX_BODY_BYTES:
            raise HTTPException(status_code=413, detail="Request body too large")

    # เก็บ raw body string ก่อน parse — เพื่อดูว่าที่รับมาจริงคืออะไร
    raw_body_str = body.decode("utf-8", errors="replace") if body else "{}"
    try:
        payload = json.loads(raw_body_str) if raw_body_str else {}
    except json.JSONDecodeError as exc:
        raise HTTPException(status_code=400, detail=f"Invalid JSON: {exc}") from exc

    # Map payload to fields using pattern (supports ocp-alertmanager -> ocp alias)
    mapped = map_payload_to_fields(payload, source)
    _, schema_id = get_pattern_for_source(source)
    mapped["_source"] = source
    mapped["_raw_body"] = raw_body_str  # string ที่รับมาจริง (ก่อน parse) — ใช้ตรวจว่า payload จริงที่มาถึง server
    mapped["_schema_id"] = schema_id
    mapped["_pattern_matched"] = schema_id is not None
    mapped["_received_at"] = datetime.now(timezone.utc).isoformat()
    mapped["_request_id"] = request_id

    ALARMS.append(mapped)
    logger.info("alarm_received source=%s request_id=%s", source, request_id)

    return JSONResponse(
        {"status": "accepted", "request_id": request_id, "source": source},
        status_code=202,
    )


# ---------- List alarms (for checking) ----------

@app.get("/api/alarms")
async def list_alarms(
    limit: int = 100,
    source: Optional[str] = None,
) -> Response:
    """List received alarms (mapped fields). Optional filter by source."""
    snapshot = list(ALARMS)
    snapshot.reverse()
    if source:

        def _matches(asrc: Optional[str], aschema: Optional[str]) -> bool:
            if asrc == source or aschema == source:
                return True
            # Route alias: ocp-alertmanager matches filter "ocp"
            if asrc and "-" in asrc and asrc.split("-")[0] == source:
                return True
            return False

        snapshot = [
            a for a in snapshot
            if _matches(a.get("_source"), a.get("_schema_id"))
        ]
    return JSONResponse(snapshot[:limit])


@app.post("/api/alarms/clear")
async def clear_alarms() -> Response:
    """Clear all alarms (reset list). แสดงเฉพาะที่ Forward มาใหม่หลัง Clear."""
    ALARMS.clear()
    return JSONResponse({"cleared": True})


# ---------- REST API pattern management ----------

@app.get("/api/patterns")
async def api_list_patterns() -> Response:
    """List all configured REST API patterns."""
    rules = get_rules()
    return JSONResponse([p.model_dump() for p in rules.patterns])


@app.get("/api/patterns/{source_id}")
async def api_get_pattern(source_id: str) -> Response:
    """Get pattern by source_id."""
    pattern = get_pattern_by_source(source_id)
    if not pattern:
        raise HTTPException(status_code=404, detail="Pattern not found")
    return JSONResponse(pattern.model_dump())


@app.get("/api/patterns/{source_id}/expected-json")
async def api_pattern_expected_json(source_id: str) -> Response:
    """Generate expected JSON from pattern - for AlertBridge/sender to match format."""
    pattern = get_pattern_by_source(source_id)
    if not pattern:
        raise HTTPException(status_code=404, detail="Pattern not found")
    mappings = [{"source_path": m.source_path, "target_field": m.target_field} for m in pattern.mappings]
    expected = gen_expected_json(mappings)
    return JSONResponse({"source_id": source_id, "expected_json": expected})


@app.post("/api/patterns")
async def api_create_pattern(request: Request) -> Response:
    """Create or update a pattern. Body: { name, source_id, mappings[], enrich? }."""
    body = await request.json()
    name = body.get("name", "Unnamed")
    source_id = body.get("source_id", "").strip()
    if not source_id:
        raise HTTPException(status_code=400, detail="source_id required")
    mappings = [
        FieldMapping(source_path=m.get("source_path", ""), target_field=m.get("target_field", ""))
        for m in body.get("mappings", [])
        if m.get("source_path") and m.get("target_field")
    ]
    enrich = body.get("enrich") or None

    pattern = ApiPattern(name=name, source_id=source_id, mappings=mappings, enrich=enrich)
    rules = get_rules()
    existing = [p for p in rules.patterns if p.source_id != source_id]
    rules = rules.model_copy(update={"patterns": existing + [pattern]})
    save_rules(rules)
    return JSONResponse(pattern.model_dump())


@app.post("/api/patterns/gen-expected-json")
async def api_gen_expected_json(request: Request) -> Response:
    """Gen expected JSON from mappings (ไม่ต้องมี pattern save แล้ว) - สำหรับส่งให้ต้นทางจัดรูปแบบ."""
    body = await request.json() or {}
    mappings = body.get("mappings", [])
    if not mappings:
        raise HTTPException(status_code=400, detail="mappings required")
    mlist = [{"source_path": m.get("source_path", ""), "target_field": m.get("target_field", "")} for m in mappings if m.get("source_path")]
    if not mlist:
        raise HTTPException(status_code=400, detail="mappings required")
    expected = gen_expected_json(mlist)
    return JSONResponse({"expected_json": expected})


@app.post("/api/patterns/auto-gen")
async def api_auto_gen_pattern(request: Request) -> Response:
    """Auto-generate mappings from sample JSON. Body: { sample } or { source_id } to use latest alarm."""
    body = await request.json() or {}
    sample = body.get("sample")
    if sample is None and body.get("source_id"):
        # Use latest alarm from that source as sample
        source_id = body["source_id"]
        for a in reversed(list(ALARMS)):
            if a.get("_source") == source_id:
                sample = {k: v for k, v in a.items() if not k.startswith("_")}
                break
        if sample is None:
            raise HTTPException(status_code=404, detail="No alarm found for this source")
    if not isinstance(sample, dict):
        raise HTTPException(status_code=400, detail="sample must be a JSON object")
    mappings = auto_gen_mappings(sample)
    return JSONResponse({"mappings": mappings})


@app.delete("/api/patterns/{source_id}")
async def api_delete_pattern(source_id: str) -> Response:
    """Delete pattern by source_id."""
    rules = get_rules()
    new_patterns = [p for p in rules.patterns if p.source_id != source_id]
    if len(new_patterns) == len(rules.patterns):
        raise HTTPException(status_code=404, detail="Pattern not found")
    save_rules(rules.model_copy(update={"patterns": new_patterns}))
    return JSONResponse({"deleted": True})


# ---------- API Key management ----------

@app.post("/api/keys/generate")
async def api_generate_key(request: Request) -> Response:
    """Generate a new API key. Body: { name? }. Returns { api_key } - show once to client."""
    body = await request.json() or {}
    name = body.get("name", "default")
    api_key = generate_api_key(name=name)
    return JSONResponse({"api_key": api_key, "name": name})


@app.get("/api/keys")
async def api_list_keys() -> Response:
    """List issued API keys (without exposing actual key)."""
    return JSONResponse(list_api_keys())


@app.delete("/api/keys/{key_id}")
async def api_revoke_key(key_id: str) -> Response:
    """Revoke an API key by id."""
    if not revoke_api_key(key_id):
        raise HTTPException(status_code=404, detail="Key not found")
    return JSONResponse({"revoked": True})


# ---------- Health ----------

@app.get("/healthz")
async def healthz() -> Response:
    return JSONResponse({"ok": True})


@app.get("/readyz")
async def readyz() -> Response:
    return JSONResponse({"ready": True})
